{"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts","turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts","turbopack:///[turbopack]/browser/runtime/base/build-base.ts","turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts"],"sourcesContent":["/**\r\n * This file contains runtime types and functions that are shared between all\r\n * TurboPack ECMAScript runtimes.\r\n *\r\n * It will be prepended to the runtime code of each runtime.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"./runtime-types.d.ts\" />\r\n\r\ntype EsmNamespaceObject = Record<string, any>;\r\n\r\n// @ts-ignore Defined in `dev-base.ts`\r\ndeclare function getOrInstantiateModuleFromParent<M>(\r\n  id: ModuleId,\r\n  sourceModule: M\r\n): M;\r\n\r\nconst REEXPORTED_OBJECTS = Symbol(\"reexported objects\");\r\n\r\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>;\r\n\r\ninterface ModuleContextEntry {\r\n  id: () => ModuleId;\r\n  module: () => any;\r\n}\r\n\r\ninterface ModuleContext {\r\n  // require call\r\n  (moduleId: ModuleId): Exports | EsmNamespaceObject;\r\n\r\n  // async import call\r\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>;\r\n\r\n  keys(): ModuleId[];\r\n\r\n  resolve(moduleId: ModuleId): ModuleId;\r\n}\r\n\r\ntype GetOrInstantiateModuleFromParent<M> = (\r\n  moduleId: ModuleId,\r\n  parentModule: M\r\n) => M;\r\n\r\ndeclare function getOrInstantiateRuntimeModule(moduleId: ModuleId, chunkPath: ChunkPath): Module;\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag;\r\n\r\nfunction defineProp(\r\n  obj: any,\r\n  name: PropertyKey,\r\n  options: PropertyDescriptor & ThisType<any>\r\n) {\r\n  if (!hasOwnProperty.call(obj, name))\r\n    Object.defineProperty(obj, name, options);\r\n}\r\n\r\n/**\r\n * Adds the getters to the exports object.\r\n */\r\nfunction esm(\r\n  exports: Exports,\r\n  getters: Record<string, (() => any) | [() => any, (v: any) => void]>\r\n) {\r\n  defineProp(exports, \"__esModule\", { value: true });\r\n  if (toStringTag) defineProp(exports, toStringTag, { value: \"Module\" });\r\n  for (const key in getters) {\r\n    const item = getters[key];\r\n    if (Array.isArray(item)) {\r\n      defineProp(exports, key, {\r\n        get: item[0],\r\n        set: item[1],\r\n        enumerable: true,\r\n      });\r\n    } else {\r\n      defineProp(exports, key, { get: item, enumerable: true });\r\n    }\r\n  }\r\n  Object.seal(exports);\r\n}\r\n\r\n/**\r\n * Makes the module an ESM with exports\r\n */\r\nfunction esmExport(\r\n  module: Module,\r\n  exports: Exports,\r\n  getters: Record<string, () => any>\r\n) {\r\n  module.namespaceObject = module.exports;\r\n  esm(exports, getters);\r\n}\r\n\r\nfunction ensureDynamicExports(module: Module, exports: Exports) {\r\n  let reexportedObjects = module[REEXPORTED_OBJECTS];\r\n\r\n  if (!reexportedObjects) {\r\n    reexportedObjects = module[REEXPORTED_OBJECTS] = [];\r\n    module.exports = module.namespaceObject = new Proxy(exports, {\r\n      get(target, prop) {\r\n        if (\r\n          hasOwnProperty.call(target, prop) ||\r\n          prop === \"default\" ||\r\n          prop === \"__esModule\"\r\n        ) {\r\n          return Reflect.get(target, prop);\r\n        }\r\n        for (const obj of reexportedObjects!) {\r\n          const value = Reflect.get(obj, prop);\r\n          if (value !== undefined) return value;\r\n        }\r\n        return undefined;\r\n      },\r\n      ownKeys(target) {\r\n        const keys = Reflect.ownKeys(target);\r\n        for (const obj of reexportedObjects!) {\r\n          for (const key of Reflect.ownKeys(obj)) {\r\n            if (key !== \"default\" && !keys.includes(key)) keys.push(key);\r\n          }\r\n        }\r\n        return keys;\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Dynamically exports properties from an object\r\n */\r\nfunction dynamicExport(\r\n  module: Module,\r\n  exports: Exports,\r\n  object: Record<string, any>\r\n) {\r\n  ensureDynamicExports(module, exports);\r\n\r\n  if (typeof object === \"object\" && object !== null) {\r\n    module[REEXPORTED_OBJECTS]!.push(object);\r\n  }\r\n}\r\n\r\nfunction exportValue(module: Module, value: any) {\r\n  module.exports = value;\r\n}\r\n\r\nfunction exportNamespace(module: Module, namespace: any) {\r\n  module.exports = module.namespaceObject = namespace;\r\n}\r\n\r\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\r\n  return () => obj[key];\r\n}\r\n\r\n/**\r\n * @returns prototype of the object\r\n */\r\nconst getProto: (obj: any) => any = Object.getPrototypeOf\r\n  ? (obj) => Object.getPrototypeOf(obj)\r\n  : (obj) => obj.__proto__;\r\n\r\n/** Prototypes that are not expanded for exports */\r\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)];\r\n\r\n/**\r\n * @param raw\r\n * @param ns\r\n * @param allowExportDefault\r\n *   * `false`: will have the raw module as default export\r\n *   * `true`: will have the default property as default export\r\n */\r\nfunction interopEsm(\r\n  raw: Exports,\r\n  ns: EsmNamespaceObject,\r\n  allowExportDefault?: boolean\r\n) {\r\n  const getters: { [s: string]: () => any } = Object.create(null);\r\n  for (\r\n    let current = raw;\r\n    (typeof current === \"object\" || typeof current === \"function\") &&\r\n    !LEAF_PROTOTYPES.includes(current);\r\n    current = getProto(current)\r\n  ) {\r\n    for (const key of Object.getOwnPropertyNames(current)) {\r\n      getters[key] = createGetter(raw, key);\r\n    }\r\n  }\r\n\r\n  // this is not really correct\r\n  // we should set the `default` getter if the imported module is a `.cjs file`\r\n  if (!(allowExportDefault && \"default\" in getters)) {\r\n    getters[\"default\"] = () => raw;\r\n  }\r\n\r\n  esm(ns, getters);\r\n  return ns;\r\n}\r\n\r\nfunction createNS(raw: Module[\"exports\"]): EsmNamespaceObject {\r\n  if (typeof raw === \"function\") {\r\n    return function (this: any, ...args: any[]) {\r\n      return raw.apply(this, args);\r\n    };\r\n  } else {\r\n    return Object.create(null);\r\n  }\r\n}\r\n\r\nfunction esmImport(\r\n  sourceModule: Module,\r\n  id: ModuleId\r\n): Exclude<Module[\"namespaceObject\"], undefined> {\r\n  const module = getOrInstantiateModuleFromParent(id, sourceModule);\r\n  if (module.error) throw module.error;\r\n\r\n  // any ES module has to have `module.namespaceObject` defined.\r\n  if (module.namespaceObject) return module.namespaceObject;\r\n\r\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\r\n  const raw = module.exports;\r\n  return (module.namespaceObject = interopEsm(\r\n    raw,\r\n    createNS(raw),\r\n    raw && (raw as any).__esModule\r\n  ));\r\n}\r\n\r\n// Add a simple runtime require so that environments without one can still pass\r\n// `typeof require` CommonJS checks so that exports are correctly registered.\r\nconst runtimeRequire =\r\n  // @ts-ignore\r\n  typeof require === \"function\"\r\n    // @ts-ignore\r\n    ? require\r\n    : function require() {\r\n        throw new Error(\"Unexpected use of runtime require\");\r\n      };\r\n\r\nfunction commonJsRequire(sourceModule: Module, id: ModuleId): Exports {\r\n  const module = getOrInstantiateModuleFromParent(id, sourceModule);\r\n  if (module.error) throw module.error;\r\n  return module.exports;\r\n}\r\n\r\n/**\r\n * `require.context` and require/import expression runtime.\r\n */\r\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\r\n  function moduleContext(id: ModuleId): Exports {\r\n    if (hasOwnProperty.call(map, id)) {\r\n      return map[id].module();\r\n    }\r\n\r\n    const e = new Error(`Cannot find module '${id}'`);\r\n    (e as any).code = \"MODULE_NOT_FOUND\";\r\n    throw e;\r\n  }\r\n\r\n  moduleContext.keys = (): ModuleId[] => {\r\n    return Object.keys(map);\r\n  };\r\n\r\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\r\n    if (hasOwnProperty.call(map, id)) {\r\n      return map[id].id();\r\n    }\r\n\r\n    const e = new Error(`Cannot find module '${id}'`);\r\n    (e as any).code = \"MODULE_NOT_FOUND\";\r\n    throw e;\r\n  };\r\n\r\n  moduleContext.import = async (id: ModuleId) => {\r\n    return await (moduleContext(id) as Promise<Exports>);\r\n  };\r\n\r\n  return moduleContext;\r\n}\r\n\r\n/**\r\n * Returns the path of a chunk defined by its data.\r\n */\r\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\r\n  return typeof chunkData === \"string\" ? chunkData : chunkData.path;\r\n}\r\n\r\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\r\n  return (\r\n    maybePromise != null &&\r\n    typeof maybePromise === \"object\" &&\r\n    \"then\" in maybePromise &&\r\n    typeof maybePromise.then === \"function\"\r\n  );\r\n}\r\n\r\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\r\n  return turbopackQueues in obj;\r\n}\r\n\r\nfunction createPromise<T>() {\r\n  let resolve: (value: T | PromiseLike<T>) => void;\r\n  let reject: (reason?: any) => void;\r\n\r\n  const promise = new Promise<T>((res, rej) => {\r\n    reject = rej;\r\n    resolve = res;\r\n  });\r\n\r\n  return {\r\n    promise,\r\n    resolve: resolve!,\r\n    reject: reject!,\r\n  };\r\n}\r\n\r\n// everything below is adapted from webpack\r\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\r\n\r\nconst turbopackQueues = Symbol(\"turbopack queues\");\r\nconst turbopackExports = Symbol(\"turbopack exports\");\r\nconst turbopackError = Symbol(\"turbopack error\");\r\n\r\nconst enum QueueStatus {\r\n  Unknown = -1,\r\n  Unresolved = 0,\r\n  Resolved = 1,\r\n}\r\n\r\ntype AsyncQueueFn = (() => void) & { queueCount: number };\r\ntype AsyncQueue = AsyncQueueFn[] & {\r\n  status: QueueStatus;\r\n};\r\n\r\nfunction resolveQueue(queue?: AsyncQueue) {\r\n  if (queue && queue.status !== QueueStatus.Resolved) {\r\n    queue.status = QueueStatus.Resolved;\r\n    queue.forEach((fn) => fn.queueCount--);\r\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()));\r\n  }\r\n}\r\n\r\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>;\r\n\r\ntype AsyncModuleExt = {\r\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void;\r\n  [turbopackExports]: Exports;\r\n  [turbopackError]?: any;\r\n};\r\n\r\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt;\r\n\r\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\r\n  return deps.map((dep): AsyncModuleExt => {\r\n    if (dep !== null && typeof dep === \"object\") {\r\n      if (isAsyncModuleExt(dep)) return dep;\r\n      if (isPromise(dep)) {\r\n        const queue: AsyncQueue = Object.assign([], {\r\n          status: QueueStatus.Unresolved,\r\n        });\r\n\r\n        const obj: AsyncModuleExt = {\r\n          [turbopackExports]: {},\r\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\r\n        };\r\n\r\n        dep.then(\r\n          (res) => {\r\n            obj[turbopackExports] = res;\r\n            resolveQueue(queue);\r\n          },\r\n          (err) => {\r\n            obj[turbopackError] = err;\r\n            resolveQueue(queue);\r\n          }\r\n        );\r\n\r\n        return obj;\r\n      }\r\n    }\r\n\r\n    return {\r\n      [turbopackExports]: dep,\r\n      [turbopackQueues]: () => {},\r\n    };\r\n  });\r\n}\r\n\r\nfunction asyncModule(\r\n  module: Module,\r\n  body: (\r\n    handleAsyncDependencies: (\r\n      deps: Dep[]\r\n    ) => Exports[] | Promise<() => Exports[]>,\r\n    asyncResult: (err?: any) => void\r\n  ) => void,\r\n  hasAwait: boolean\r\n) {\r\n  const queue: AsyncQueue | undefined = hasAwait\r\n    ? Object.assign([], { status: QueueStatus.Unknown })\r\n    : undefined;\r\n\r\n  const depQueues: Set<AsyncQueue> = new Set();\r\n\r\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>();\r\n\r\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\r\n    [turbopackExports]: module.exports,\r\n    [turbopackQueues]: (fn) => {\r\n      queue && fn(queue);\r\n      depQueues.forEach(fn);\r\n      promise[\"catch\"](() => {});\r\n    },\r\n  } satisfies AsyncModuleExt);\r\n\r\n  const attributes: PropertyDescriptor = {\r\n    get(): any {\r\n      return promise;\r\n    },\r\n    set(v: any) {\r\n      // Calling `esmExport` leads to this.\r\n      if (v !== promise) {\r\n        promise[turbopackExports] = v;\r\n      }\r\n    },\r\n  };\r\n\r\n  Object.defineProperty(module, \"exports\", attributes);\r\n  Object.defineProperty(module, \"namespaceObject\", attributes);\r\n\r\n  function handleAsyncDependencies(deps: Dep[]) {\r\n    const currentDeps = wrapDeps(deps);\r\n\r\n    const getResult = () =>\r\n      currentDeps.map((d) => {\r\n        if (d[turbopackError]) throw d[turbopackError];\r\n        return d[turbopackExports];\r\n      });\r\n\r\n    const { promise, resolve } = createPromise<() => Exports[]>();\r\n\r\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\r\n      queueCount: 0,\r\n    });\r\n\r\n    function fnQueue(q: AsyncQueue) {\r\n      if (q !== queue && !depQueues.has(q)) {\r\n        depQueues.add(q);\r\n        if (q && q.status === QueueStatus.Unresolved) {\r\n          fn.queueCount++;\r\n          q.push(fn);\r\n        }\r\n      }\r\n    }\r\n\r\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue));\r\n\r\n    return fn.queueCount ? promise : getResult();\r\n  }\r\n\r\n  function asyncResult(err?: any) {\r\n    if (err) {\r\n      reject((promise[turbopackError] = err));\r\n    } else {\r\n      resolve(promise[turbopackExports]);\r\n    }\r\n\r\n    resolveQueue(queue);\r\n  }\r\n\r\n  body(handleAsyncDependencies, asyncResult);\r\n\r\n  if (queue && queue.status === QueueStatus.Unknown) {\r\n    queue.status = QueueStatus.Unresolved;\r\n  }\r\n}\r\n\r\n/**\r\n * A pseudo \"fake\" URL object to resolve to its relative path.\r\n *\r\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\r\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\r\n * hydration mismatch.\r\n *\r\n * This is based on webpack's existing implementation:\r\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\r\n */\r\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\r\n  const realUrl = new URL(inputUrl, \"x:/\");\r\n  const values: Record<string, any> = {};\r\n  for (const key in realUrl) values[key] = (realUrl as any)[key];\r\n  values.href = inputUrl;\r\n  values.pathname = inputUrl.replace(/[?#].*/, \"\");\r\n  values.origin = values.protocol = \"\";\r\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl;\r\n  for (const key in values)\r\n    Object.defineProperty(this, key, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      value: values[key],\r\n    });\r\n};\r\n\r\nrelativeURL.prototype = URL.prototype;\r\n\r\n/**\r\n * Utility function to ensure all variants of an enum are handled.\r\n */\r\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\r\n  throw new Error(`Invariant: ${computeMessage(never)}`);\r\n}\r\n\r\n/**\r\n * A stub function to make `require` available but non-functional in ESM.\r\n */\r\nfunction requireStub(_moduleId: ModuleId): never {\r\n  throw new Error(\"dynamic usage of require is not supported\");\r\n}\r\n","/**\r\n * This file contains runtime types and functions that are shared between all\r\n * Turbopack *development* ECMAScript runtimes.\r\n *\r\n * It will be appended to the runtime code of each runtime right after the\r\n * shared runtime utils.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../base/globals.d.ts\" />\r\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\r\n\r\n// Used in WebWorkers to tell the runtime about the chunk base path\r\ndeclare var TURBOPACK_WORKER_LOCATION: string;\r\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\r\n// Note it's stored in reversed order to use push and pop\r\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined;\r\n\r\n// Injected by rust code\r\ndeclare var CHUNK_BASE_PATH: string;\r\ndeclare var CHUNK_SUFFIX_PATH: string;\r\n\r\n// Provided by build or dev base\r\ndeclare function instantiateModule(id: ModuleId, source: SourceInfo): Module;\r\n\r\ntype RuntimeParams = {\r\n  otherChunks: ChunkData[];\r\n  runtimeModuleIds: ModuleId[];\r\n};\r\n\r\ntype ChunkRegistration = [\r\n  chunkPath: ChunkScript,\r\n  chunkModules: ModuleFactories,\r\n  params: RuntimeParams | undefined\r\n];\r\n\r\ntype ChunkList = {\r\n  script: ChunkListScript;\r\n  chunks: ChunkData[];\r\n  source: \"entry\" | \"dynamic\";\r\n};\r\n\r\nenum SourceType {\r\n  /**\r\n   * The module was instantiated because it was included in an evaluated chunk's\r\n   * runtime.\r\n   */\r\n  Runtime = 0,\r\n  /**\r\n   * The module was instantiated because a parent module imported it.\r\n   */\r\n  Parent = 1,\r\n  /**\r\n   * The module was instantiated because it was included in a chunk's hot module\r\n   * update.\r\n   */\r\n  Update = 2,\r\n}\r\n\r\ntype SourceInfo =\r\n  | {\r\n      type: SourceType.Runtime;\r\n      chunkPath: ChunkPath;\r\n    }\r\n  | {\r\n      type: SourceType.Parent;\r\n      parentId: ModuleId;\r\n    }\r\n  | {\r\n      type: SourceType.Update;\r\n      parents?: ModuleId[];\r\n    };\r\n\r\ninterface RuntimeBackend {\r\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void;\r\n  loadChunk: (chunkUrl: ChunkUrl, source: SourceInfo) => Promise<void>;\r\n}\r\n\r\ninterface DevRuntimeBackend {\r\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>;\r\n  unloadChunk?: (chunkUrl: ChunkUrl) => void;\r\n  restart: () => void;\r\n}\r\n\r\nconst moduleFactories: ModuleFactories = Object.create(null);\r\n/**\r\n * Module IDs that are instantiated as part of the runtime of a chunk.\r\n */\r\nconst runtimeModules: Set<ModuleId> = new Set();\r\n/**\r\n * Map from module ID to the chunks that contain this module.\r\n *\r\n * In HMR, we need to keep track of which modules are contained in which so\r\n * chunks. This is so we don't eagerly dispose of a module when it is removed\r\n * from chunk A, but still exists in chunk B.\r\n */\r\nconst moduleChunksMap: Map<ModuleId, Set<ChunkPath>> = new Map();\r\n/**\r\n * Map from a chunk path to all modules it contains.\r\n */\r\nconst chunkModulesMap: Map<ChunkPath, Set<ModuleId>> = new Map();\r\n/**\r\n * Chunk lists that contain a runtime. When these chunk lists receive an update\r\n * that can't be reconciled with the current state of the page, we need to\r\n * reload the runtime entirely.\r\n */\r\nconst runtimeChunkLists: Set<ChunkListPath> = new Set();\r\n/**\r\n * Map from a chunk list to the chunk paths it contains.\r\n */\r\nconst chunkListChunksMap: Map<ChunkListPath, Set<ChunkPath>> = new Map();\r\n/**\r\n * Map from a chunk path to the chunk lists it belongs to.\r\n */\r\nconst chunkChunkListsMap: Map<ChunkPath, Set<ChunkListPath>> = new Map();\r\n\r\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map();\r\n\r\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map();\r\n\r\nasync function loadChunk(\r\n  source: SourceInfo,\r\n  chunkData: ChunkData\r\n): Promise<any> {\r\n  if (typeof chunkData === \"string\") {\r\n    return loadChunkPath(source, chunkData);\r\n  }\r\n\r\n  const includedList = chunkData.included || [];\r\n  const modulesPromises = includedList.map((included) => {\r\n    if (moduleFactories[included]) return true;\r\n    return availableModules.get(included);\r\n  });\r\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\r\n    // When all included items are already loaded or loading, we can skip loading ourselves\r\n    return Promise.all(modulesPromises);\r\n  }\r\n\r\n  const includedModuleChunksList = chunkData.moduleChunks || [];\r\n  const moduleChunksPromises = includedModuleChunksList\r\n    .map((included) => {\r\n      // TODO(alexkirsz) Do we need this check?\r\n      // if (moduleFactories[included]) return true;\r\n      return availableModuleChunks.get(included);\r\n    })\r\n    .filter((p) => p);\r\n\r\n  let promise;\r\n  if (moduleChunksPromises.length > 0) {\r\n    // Some module chunks are already loaded or loading.\r\n\r\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\r\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\r\n      return Promise.all(moduleChunksPromises);\r\n    }\r\n\r\n    const moduleChunksToLoad: Set<ChunkPath> = new Set();\r\n    for (const moduleChunk of includedModuleChunksList) {\r\n      if (!availableModuleChunks.has(moduleChunk)) {\r\n        moduleChunksToLoad.add(moduleChunk);\r\n      }\r\n    }\r\n\r\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\r\n      const promise = loadChunkPath(source, moduleChunkToLoad);\r\n\r\n      availableModuleChunks.set(moduleChunkToLoad, promise);\r\n\r\n      moduleChunksPromises.push(promise);\r\n    }\r\n\r\n    promise = Promise.all(moduleChunksPromises);\r\n  } else {\r\n    promise = loadChunkPath(source, chunkData.path);\r\n\r\n    // Mark all included module chunks as loading if they are not already loaded or loading.\r\n    for (const includedModuleChunk of includedModuleChunksList) {\r\n      if (!availableModuleChunks.has(includedModuleChunk)) {\r\n        availableModuleChunks.set(includedModuleChunk, promise);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const included of includedList) {\r\n    if (!availableModules.has(included)) {\r\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\r\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\r\n      availableModules.set(included, promise);\r\n    }\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\nasync function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl) {\r\n  try {\r\n    await BACKEND.loadChunk(chunkUrl, source);\r\n  } catch (error) {\r\n    let loadReason;\r\n    switch (source.type) {\r\n      case SourceType.Runtime:\r\n        loadReason = `as a runtime dependency of chunk ${source.chunkPath}`;\r\n        break;\r\n      case SourceType.Parent:\r\n        loadReason = `from module ${source.parentId}`;\r\n        break;\r\n      case SourceType.Update:\r\n        loadReason = \"from an HMR update\";\r\n        break;\r\n      default:\r\n        invariant(source, (source) => `Unknown source type: ${source?.type}`);\r\n    }\r\n    throw new Error(\r\n      `Failed to load chunk ${chunkUrl} ${loadReason}${\r\n        error ? `: ${error}` : \"\"\r\n      }`,\r\n      error\r\n        ? {\r\n            cause: error,\r\n          }\r\n        : undefined\r\n    );\r\n  }\r\n}\r\n\r\nasync function loadChunkPath(\r\n  source: SourceInfo,\r\n  chunkPath: ChunkPath\r\n): Promise<any> {\r\n  const url = getChunkRelativeUrl(chunkPath);\r\n  return loadChunkByUrl(source, url);\r\n}\r\n\r\n/**\r\n * Returns an absolute url to an asset.\r\n */\r\nfunction createResolvePathFromModule(\r\n  resolver: (moduleId: string) => Exports\r\n): (moduleId: string) => string {\r\n  return function resolvePathFromModule(moduleId: string): string {\r\n    const exported = resolver(moduleId);\r\n    return exported?.default ?? exported;\r\n  };\r\n}\r\n\r\n/**\r\n * no-op for browser\r\n * @param modulePath\r\n */\r\nfunction resolveAbsolutePath(modulePath?: string): string {\r\n  return `/ROOT/${modulePath ?? \"\"}`;\r\n}\r\n\r\nfunction getWorkerBlobURL(chunks: ChunkPath[]): string {\r\n  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\r\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\r\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\r\n  let blob = new Blob([bootstrap], { type: \"text/javascript\" });\r\n  return URL.createObjectURL(blob);\r\n}\r\n\r\n/**\r\n * Adds a module to a chunk.\r\n */\r\nfunction addModuleToChunk(moduleId: ModuleId, chunkPath: ChunkPath) {\r\n  let moduleChunks = moduleChunksMap.get(moduleId);\r\n  if (!moduleChunks) {\r\n    moduleChunks = new Set([chunkPath]);\r\n    moduleChunksMap.set(moduleId, moduleChunks);\r\n  } else {\r\n    moduleChunks.add(chunkPath);\r\n  }\r\n\r\n  let chunkModules = chunkModulesMap.get(chunkPath);\r\n  if (!chunkModules) {\r\n    chunkModules = new Set([moduleId]);\r\n    chunkModulesMap.set(chunkPath, chunkModules);\r\n  } else {\r\n    chunkModules.add(moduleId);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the first chunk that included a module.\r\n * This is used by the Node.js backend, hence why it's marked as unused in this\r\n * file.\r\n */\r\nfunction getFirstModuleChunk(moduleId: ModuleId) {\r\n  const moduleChunkPaths = moduleChunksMap.get(moduleId);\r\n  if (moduleChunkPaths == null) {\r\n    return null;\r\n  }\r\n\r\n  return moduleChunkPaths.values().next().value;\r\n}\r\n\r\n/**\r\n * Instantiates a runtime module.\r\n */\r\nfunction instantiateRuntimeModule(\r\n  moduleId: ModuleId,\r\n  chunkPath: ChunkPath\r\n): Module {\r\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\r\n}\r\n/**\r\n * Returns the URL relative to the origin where a chunk can be fetched from.\r\n */\r\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\r\n  return `${CHUNK_BASE_PATH}${chunkPath\r\n    .split(\"/\")\r\n    .map((p) => encodeURIComponent(p))\r\n    .join(\"/\")}${CHUNK_SUFFIX_PATH}` as ChunkUrl;\r\n}\r\n\r\n/**\r\n * Return the ChunkPath from a ChunkScript.\r\n */\r\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath;\r\nfunction getPathFromScript(chunkScript: ChunkListPath | ChunkListScript): ChunkListPath;\r\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript): ChunkPath | ChunkListPath {\r\n  if (typeof chunkScript === \"string\") {\r\n    return chunkScript as ChunkPath | ChunkListPath;\r\n  }\r\n  const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== \"undefined\"\r\n    ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\r\n    : chunkScript.getAttribute(\"src\")!;\r\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, \"\"));\r\n  const path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\r\n  return path as ChunkPath | ChunkListPath;\r\n}\r\n\r\n/**\r\n * Marks a chunk list as a runtime chunk list. There can be more than one\r\n * runtime chunk list. For instance, integration tests can have multiple chunk\r\n * groups loaded at runtime, each with its own chunk list.\r\n */\r\nfunction markChunkListAsRuntime(chunkListPath: ChunkListPath) {\r\n  runtimeChunkLists.add(chunkListPath);\r\n}\r\n\r\nfunction registerChunk([\r\n  chunkScript,\r\n  chunkModules,\r\n  runtimeParams,\r\n]: ChunkRegistration) {\r\n  const chunkPath = getPathFromScript(chunkScript);\r\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\r\n    if (!moduleFactories[moduleId]) {\r\n      moduleFactories[moduleId] = moduleFactory;\r\n    }\r\n    addModuleToChunk(moduleId, chunkPath);\r\n  }\r\n\r\n  return BACKEND.registerChunk(chunkPath, runtimeParams);\r\n}\r\n\r\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\r\n/**\r\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\r\n */\r\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\r\n  return regexJsUrl.test(chunkUrlOrPath);\r\n}\r\n\r\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\r\n/**\r\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\r\n */\r\nfunction isCss(chunkUrl: ChunkUrl): boolean {\r\n  return regexCssUrl.test(chunkUrl);\r\n}\r\n","/// <reference path=\"./runtime-base.ts\" />\r\n/// <reference path=\"./dummy.ts\" />\r\n\r\ndeclare var augmentContext: ((context: unknown) => unknown);\r\n\r\nconst moduleCache: ModuleCache<Module> = {};\r\n\r\n/**\r\n * Gets or instantiates a runtime module.\r\n */\r\n// @ts-ignore\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction getOrInstantiateRuntimeModule(\r\n  moduleId: ModuleId,\r\n  chunkPath: ChunkPath,\r\n): Module {\r\n  const module = moduleCache[moduleId];\r\n  if (module) {\r\n    if (module.error) {\r\n      throw module.error;\r\n    }\r\n    return module;\r\n  }\r\n\r\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath });\r\n}\r\n\r\n/**\r\n * Retrieves a module from the cache, or instantiate it if it is not cached.\r\n */\r\n// Used by the backend\r\n// @ts-ignore\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<Module> = (\r\n  id,\r\n  sourceModule\r\n) => {\r\n  const module = moduleCache[id];\r\n\r\n  if (module) {\r\n    return module;\r\n  }\r\n\r\n  return instantiateModule(id, {\r\n    type: SourceType.Parent,\r\n    parentId: sourceModule.id,\r\n  });\r\n};\r\n\r\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\r\n  const moduleFactory = moduleFactories[id];\r\n  if (typeof moduleFactory !== \"function\") {\r\n    // This can happen if modules incorrectly handle HMR disposes/updates,\r\n    // e.g. when they keep a `setTimeout` around which still executes old code\r\n    // and contains e.g. a `require(\"something\")` call.\r\n    let instantiationReason;\r\n    switch (source.type) {\r\n      case SourceType.Runtime:\r\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\r\n        break;\r\n      case SourceType.Parent:\r\n        instantiationReason = `because it was required from module ${source.parentId}`;\r\n        break;\r\n      case SourceType.Update:\r\n        instantiationReason = \"because of an HMR update\";\r\n        break;\r\n      default:\r\n        invariant(source, (source) => `Unknown source type: ${source?.type}`);\r\n    }\r\n    throw new Error(\r\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\r\n    );\r\n  }\r\n\r\n  switch (source.type) {\r\n    case SourceType.Runtime:\r\n      runtimeModules.add(id);\r\n      break;\r\n    case SourceType.Parent:\r\n      // No need to add this module as a child of the parent module here, this\r\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\r\n      break;\r\n    case SourceType.Update:\r\n      throw new Error('Unexpected')\r\n    default:\r\n      invariant(source, (source) => `Unknown source type: ${source?.type}`);\r\n  }\r\n\r\n  const module: Module = {\r\n    exports: {},\r\n    error: undefined,\r\n    loaded: false,\r\n    id,\r\n    namespaceObject: undefined,\r\n  };\r\n\r\n  moduleCache[id] = module;\r\n\r\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\r\n  try {\r\n    const sourceInfo: SourceInfo = { type: SourceType.Parent, parentId: id };\r\n\r\n    const r = commonJsRequire.bind(null, module);\r\n    moduleFactory.call(\r\n      module.exports,\r\n      augmentContext({\r\n        a: asyncModule.bind(null, module),\r\n        e: module.exports,\r\n        r: commonJsRequire.bind(null, module),\r\n        t: runtimeRequire,\r\n        f: moduleContext,\r\n        i: esmImport.bind(null, module),\r\n        s: esmExport.bind(null, module, module.exports),\r\n        j: dynamicExport.bind(null, module, module.exports),\r\n        v: exportValue.bind(null, module),\r\n        n: exportNamespace.bind(null, module),\r\n        m: module,\r\n        c: moduleCache,\r\n        M: moduleFactories,\r\n        l: loadChunk.bind(null, sourceInfo),\r\n        L: loadChunkByUrl.bind(null, sourceInfo),\r\n        w: loadWebAssembly.bind(null, sourceInfo),\r\n        u: loadWebAssemblyModule.bind(null, sourceInfo),\r\n        g: globalThis,\r\n        P: resolveAbsolutePath,\r\n        U: relativeURL,\r\n        R: createResolvePathFromModule(r),\r\n        b: getWorkerBlobURL,\r\n        d: typeof module.id === \"string\" ? module.id.replace(/(^|\\/)\\/+$/, \"\") : module.id\r\n      })\r\n    );\r\n  } catch (error) {\r\n    module.error = error as any;\r\n    throw error;\r\n  }\r\n\r\n  module.loaded = true;\r\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\r\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\r\n    interopEsm(module.exports, module.namespaceObject);\r\n  }\r\n\r\n  return module;\r\n}\r\n\r\n","/**\r\n * This file contains the runtime code specific to the Turbopack development\r\n * ECMAScript DOM runtime.\r\n *\r\n * It will be appended to the base development runtime code.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\r\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\r\n\r\ntype ChunkResolver = {\r\n  resolved: boolean;\r\n  resolve: () => void;\r\n  reject: (error?: Error) => void;\r\n  promise: Promise<void>;\r\n};\r\n\r\nlet BACKEND: RuntimeBackend;\r\n\r\nfunction augmentContext(context: unknown): unknown {\r\n  return context;\r\n}\r\n\r\nfunction fetchWebAssembly(wasmChunkPath: ChunkPath) {\r\n  return fetch(getChunkRelativeUrl(wasmChunkPath));\r\n}\r\n\r\nasync function loadWebAssembly(\r\n  _source: unknown,\r\n  wasmChunkPath: ChunkPath,\r\n  importsObj: WebAssembly.Imports\r\n): Promise<Exports> {\r\n  const req = fetchWebAssembly(wasmChunkPath);\r\n\r\n  const { instance } = await WebAssembly.instantiateStreaming(req, importsObj);\r\n\r\n  return instance.exports;\r\n}\r\n\r\nasync function loadWebAssemblyModule(\r\n  _source: unknown,\r\n  wasmChunkPath: ChunkPath\r\n): Promise<WebAssembly.Module> {\r\n  const req = fetchWebAssembly(wasmChunkPath);\r\n\r\n  return await WebAssembly.compileStreaming(req);\r\n}\r\n\r\n/**\r\n * Maps chunk paths to the corresponding resolver.\r\n */\r\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map();\r\n\r\n(() => {\r\n  BACKEND = {\r\n    async registerChunk(chunkPath, params) {\r\n      const chunkUrl = getChunkRelativeUrl(chunkPath);\r\n\r\n      const resolver = getOrCreateResolver(chunkUrl);\r\n      resolver.resolve();\r\n\r\n      if (params == null) {\r\n        return;\r\n      }\r\n\r\n      for (const otherChunkData of params.otherChunks) {\r\n        const otherChunkPath = getChunkPath(otherChunkData)\r\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\r\n\r\n        // Chunk might have started loading, so we want to avoid triggering another load.\r\n        getOrCreateResolver(otherChunkUrl);\r\n      }\r\n\r\n      // This waits for chunks to be loaded, but also marks included items as available.\r\n      await Promise.all(\r\n        params.otherChunks.map((otherChunkData) =>\r\n          loadChunk({ type: SourceType.Runtime, chunkPath }, otherChunkData)\r\n        )\r\n      );\r\n\r\n      if (params.runtimeModuleIds.length > 0) {\r\n        for (const moduleId of params.runtimeModuleIds) {\r\n          getOrInstantiateRuntimeModule(moduleId, chunkPath);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Loads the given chunk, and returns a promise that resolves once the chunk\r\n     * has been loaded.\r\n    */\r\n    loadChunk(chunkUrl, source) {\r\n      return doLoadChunk(chunkUrl, source);\r\n    },\r\n  };\r\n\r\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\r\n    let resolver = chunkResolvers.get(chunkUrl);\r\n    if (!resolver) {\r\n      let resolve: () => void;\r\n      let reject: (error?: Error) => void;\r\n      const promise = new Promise<void>((innerResolve, innerReject) => {\r\n        resolve = innerResolve;\r\n        reject = innerReject;\r\n      });\r\n      resolver = {\r\n        resolved: false,\r\n        promise,\r\n        resolve: () => {\r\n          resolver!.resolved = true;\r\n          resolve();\r\n        },\r\n        reject: reject!,\r\n      };\r\n      chunkResolvers.set(chunkUrl, resolver);\r\n    }\r\n    return resolver;\r\n  }\r\n\r\n   /**\r\n    * Loads the given chunk, and returns a promise that resolves once the chunk\r\n    * has been loaded.\r\n    */\r\n  function doLoadChunk(chunkUrl: ChunkUrl, source: SourceInfo) {\r\n    const resolver = getOrCreateResolver(chunkUrl);\r\n    if (resolver.resolved) {\r\n      return resolver.promise;\r\n    }\r\n\r\n    if (source.type === SourceType.Runtime) {\r\n      // We don't need to load chunks references from runtime code, as they're already\r\n      // present in the DOM.\r\n\r\n      if (isCss(chunkUrl)) {\r\n        // CSS chunks do not register themselves, and as such must be marked as\r\n        // loaded instantly.\r\n        resolver.resolve();\r\n      }\r\n\r\n      // We need to wait for JS chunks to register themselves within `registerChunk`\r\n      // before we can start instantiating runtime modules, hence the absence of\r\n      // `resolver.resolve()` in this branch.\r\n\r\n      return resolver.promise;\r\n    }\r\n\r\n    if (typeof importScripts === \"function\") {\r\n      // We're in a web worker\r\n      if (isCss(chunkUrl)) {\r\n        // ignore\r\n      } else if (isJs(chunkUrl)) {\r\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl);\r\n        importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\r\n      } else {\r\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\r\n      }\r\n    } else {\r\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\r\n      const decodedChunkUrl = decodeURI(chunkUrl);\r\n\r\n      if (isCss(chunkUrl)) {\r\n        const previousLinks = document.querySelectorAll(\r\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\r\n        );\r\n        if (previousLinks.length > 0) {\r\n          // CSS chunks do not register themselves, and as such must be marked as\r\n          // loaded instantly.\r\n          resolver.resolve();\r\n        } else {\r\n          const link = document.createElement(\"link\");\r\n          link.rel = \"stylesheet\";\r\n          link.href = chunkUrl;\r\n          link.onerror = () => {\r\n            resolver.reject();\r\n          };\r\n          link.onload = () => {\r\n            // CSS chunks do not register themselves, and as such must be marked as\r\n            // loaded instantly.\r\n            resolver.resolve();\r\n          };\r\n          document.body.appendChild(link);\r\n        }\r\n      } else if (isJs(chunkUrl)) {\r\n        const previousScripts = document.querySelectorAll(\r\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\r\n        );\r\n        if (previousScripts.length > 0) {\r\n          // There is this edge where the script already failed loading, but we\r\n          // can't detect that. The Promise will never resolve in this case.\r\n          for (const script of Array.from(previousScripts)) {\r\n            script.addEventListener(\"error\", () => {\r\n              resolver.reject();\r\n            });\r\n          }\r\n        } else {\r\n          const script = document.createElement(\"script\");\r\n          script.src = chunkUrl;\r\n          // We'll only mark the chunk as loaded once the script has been executed,\r\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\r\n          // this branch.\r\n          script.onerror = () => {\r\n            resolver.reject();\r\n          };\r\n          document.body.appendChild(script);\r\n        }\r\n      } else {\r\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\r\n      }\r\n    }\r\n\r\n    return resolver.promise;\r\n  }\r\n\r\n})();\r\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3]}